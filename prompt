#!/bin/bash

# USAGE
#
# If you have to run the same program over and over with the last few arguments
# always changing, you can use this command like this:
#
# prompt myprog --arg1 -arg2 arg3 "this is arg 4"
#
# A prompt will show up which you can exit using Ctrl-D.
#
# You can add multiple arguments per each prompt line. Spaces always separate
# arguments and there is currently no way to escape spaces or use quotation
# marks.
#
# Lines entered into the prompt will be stored into a history name derived from
# the supplied command complete with its arguments, and ending with the
# .history file extension. Lines that result in errors (non-zero exit codes)
# from the command will also be added to a file named the same, but which ends
# in .errors instead of ending in .history. The .errors file logs all errors,
# even for prompts that start with a space.
#
# You can call the program multiple times with one prompt line by using the
# semicolon (;). For example, this prompt:
#
# myprog -a> foo; bar
#
# will invoke myprog -a foo, then myprog -a bar, and then log "foo; bar" into
# the .history file. If either invokation of myprog returns an error, the whole
# prompt "foo; bar" will be logged to the .errors file. It does not matter that
# the part that contained "bar" starts with a space (located right after the
# semicolon). Whether or not a line gets logged to .history only depends on
# whether the whole prompt starts with a space.
#
# If you wish to use a literal semicolon, you have to escape it using a
# backslash, like so: foo\; bar.
#
# Please set the disallowed variable depending on whether you're on Linux,
# Windows, or some other operating system.


# Set characters not allowed within a file name on your platform. If you want
# to use a backslash (\), make sure to escape it (\\), because it'll be used by
# the tr command, which needs the backslash escaped.
disallowed='<>:"/\\|?' # for Windows.
if [[ "$(uname -s)" == "Linux" ]]; then
  disallowed='/' # for Linux
  fi
# If you're on another platform, set the variable here:
# disallowed='/'

# The file name will have disallowed characters replaced with underscores and
# will end in .history. Prompt lines that result in an error will also be added
# to a file that is named the same, but ends in .errors instead of .history.
this_histfile_base="$(printf '%s' "$*" | tr "$disallowed" _)"
this_histfile="$this_histfile_base"".history"
this_errorfile="$this_histfile_base"".errors"

# Usage: join joinchar [arg ...]
join() {
  local IFS="$1"
  shift
  printf '%s\n' "$*"
  }

# The command line parser: split on separator but not within quotes or when
# escaped; allow comments that end on separator.
#
# The escape character is \, the separator is ;.
#
#
#
# States:
#
# normal
# comment (starts with # and goes on until separator (;) or EOL)
# after-separator (for skipping whitespace after ;)
# single-quoted (with ')
# double-quoted (with ")
# escape-on-first-character (for commands)
# escape-normal
# escape-single-quoted
# escape-double-quoted
#
#
#
# Allowed actions within states - transitions are not mentioned, they're
# documented further below - here we only mention actions that don't change the
# current state:
#
# normal:
# - encounter a normal non-space character and add it to current entry in the
#   args array being built (the args array is the accumulator for the parser)
# - encounter a space and finish current entry in args array and start a new,
#   empty one
#
# comment:
# - encounter any non-special character and skip it
#
# after-separator:
# - encounter a whitespace character and skip it
#
# single-quoted:
# - encounter any character, space or non-space, and add it to the current
#   argument being built
#
# double-quoted:
# - encounter any character, space or non-space, and add it to the current
#   argument being built
#
#
#
# Allowed state transitions:
#
# Trigger                    Transition
#
# #                          normal -> comment
# ;                          normal -> after-separator
# \                          normal -> escape-on-first-character
# \                          normal -> escape-normal
# '                          normal -> single-quoted (set continuation to "normal")
# "                          normal -> double-quoted (set continuation to "normal")
#
# ;                          comment -> after-separator
# \                          comment -> escape-comment
# '                          comment -> single-quoted (set continuation to "comment")
# "                          comment -> double-quoted (set continuation to "comment")
#
# #                          after-separator -> comment
# ;                          after-separator -> after-separator
# \                          after-separator -> escape-on-first-character
# '                          after-separator -> singe-quoted (set continuation to "normal")
# "                          after-separator -> double-quoted (set continuation to "normal")
# any other non-whitespace   after-separator -> normal
#
# \                          single-quoted -> escape-single-quoted
# '                          single-quoted -> normal/comment (depending on continuation)
#
# \                          double-quoted -> escape-double-quoted
# "                          double-quoted -> normal/comment (depending on continuation)
#
# any                        escape-normal -> normal
#
# any                        escape-comment -> comment
#
# any                        escape-single-quoted -> single-quoted
#
# any                        escape-double-quoted -> double-quoted
#
# (at end of input)          EOL - note this is not represented within the
#                              state loop, it's performed after the loop.
# Note: Starting bash 5.3, you will be able to do read -E, which is like
# read -e, but has history. However, bash 5.3 has not been released yet.
while IFS=';' read -a linearr -e -p "$*> "; do

  line="$(join ";" "${linearr[@]}")"
  # echo "line: $line"

  if [ -z "$line" ]; then
    continue
    fi

  if ! [[ "${line:0:1}" == " " ]]; then # do not log lines that start with a space
    printf '%s\n' "$line" >> "$this_histfile"
    fi

  error=0
  for subline in "${linearr[@]}"; do
    # echo "subline: $subline"


    "$@" $subline # note: the variable line will be expanded (so you can enter multiple arguments).
    if [ "$?" -gt 0 ]; then
      error=1
      fi

    printf '\n'
    done

  # Log prompts that cause errors
  if [ "$error" -gt 0 ]; then
    printf '%s\n' "$line" >> "$this_errorfile"
    fi

  done
